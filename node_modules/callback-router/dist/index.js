'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pathToRegexp = _interopDefault(require('path-to-regexp'));

var ROUTE_CHANGE_FORCE_PUSH_STATE = 'forcePush';
var ROUTE_CHANGE_FORCE_REPLACE_STATE = 'forceReplace';
var ROUTE_CHANGE_INITIALIZE = 'init';
var ROUTE_CHANGE_POP_STATE = 'pop';
var ROUTE_CHANGE_PUSH_STATE = 'push';
var ROUTE_CHANGE_REPLACE_STATE = 'replace';
var ROUTE_CHANGE_UNKNOWN = 'unknown';

var REGEX_SEGMENT_PARAM = /^:/;
var REGEX_SEGMENT_OPTIONAL = /\?$/;
function compareRoutes(_a, _b) {
    var routeA = _a[0];
    var routeB = _b[0];
    var routePartsA = routeA.split('/');
    var routePartsB = routeB.split('/');
    var routePartsLengthA = routePartsA.length;
    var routePartsLengthB = routePartsB.length;
    // Prioritize path with most segments
    if (routePartsLengthA > routePartsLengthB) {
        return -1;
    }
    else if (routePartsLengthA < routePartsLengthB) {
        return 1;
    }
    // Compare each path segment in order
    var minLength = Math.min(routePartsLengthA, routePartsLengthB);
    for (var i = 1; i < minLength; i += 1) {
        var routePartA = routePartsA[i];
        var routePartB = routePartsB[i];
        // Skip matching parts
        if (routePartA === routePartB) {
            continue;
        }
        // Prioritize non-param
        var isParamA = REGEX_SEGMENT_PARAM.test(routePartA);
        var isParamB = REGEX_SEGMENT_PARAM.test(routePartB);
        if (!isParamA && isParamB) {
            return -1;
        }
        else if (isParamA && !isParamB) {
            return 1;
        }
        else if (isParamA && isParamB) {
            // Prioritize required param
            var isOptionalA = REGEX_SEGMENT_OPTIONAL.test(routePartA);
            var isOptionalB = REGEX_SEGMENT_OPTIONAL.test(routePartB);
            if (!isOptionalA && isOptionalB) {
                return -1;
            }
            else if (isOptionalA && !isOptionalB) {
                return 1;
            }
            continue;
        }
        // Wildcard routes
        var wildcardIndexA = routePartA.indexOf('*');
        var wildcardIndexB = routePartB.indexOf('*');
        if (wildcardIndexA < 0 && wildcardIndexB >= 0) {
            return -1;
        }
        else if (wildcardIndexB < 0 && wildcardIndexA >= 0) {
            return 1;
        }
        else if (wildcardIndexA > wildcardIndexB) {
            return -1;
        }
        else if (wildcardIndexA < wildcardIndexB) {
            return 1;
        }
        // Alphabetize
        if (routePartA < routePartB) {
            return -1;
        }
        else if (routePartA > routePartB) {
            return 1;
        }
    }
    return 0;
}
function processRoutes(routeMap, callback) {
    return Object.entries(routeMap)
        .map(function (_a) {
        var path = _a[0], routeConfig = _a[1];
        var _b = typeof routeConfig === 'function'
            ? { callback: routeConfig }
            : routeConfig, routeCallback = _b.callback, _c = _b.exact, exact = _c === void 0 ? false : _c, _d = _b.last, last = _d === void 0 ? true : _d, _e = _b.navigate, navigate = _e === void 0 ? false : _e, _f = _b.strict, strict = _f === void 0 ? false : _f;
        var options = {
            end: exact,
            sensitive: false,
            strict: strict,
        };
        var keys = [];
        var regexp = pathToRegexp(path, keys, options);
        var paramNames = keys.map(function (_a) {
            var name = _a.name;
            return name;
        });
        function matchRoute(pathname) {
            var match = regexp.exec(pathname);
            if (!match) {
                return null;
            }
            var url = match[0], values = match.slice(1);
            var isExact = pathname === url;
            if (exact && !isExact) {
                return null;
            }
            var params = {};
            paramNames.forEach(function (key, i) {
                params[key] = values[i];
            });
            return {
                callback: (function () {
                    var args = [];
                    for (var _a = 0; _a < arguments.length; _a++) {
                        args[_a] = arguments[_a];
                    }
                    var result = routeCallback.apply(void 0, args);
                    if (callback) {
                        result = callback(result);
                    }
                    return result;
                }),
                isExact: isExact,
                params: params,
                path: path,
                url: path === '/' && url === '' ? '/' : url,
            };
        }
        return [path, matchRoute, navigate, last];
    })
        .sort(compareRoutes);
}
function getMatchingRoutes(pathname, routes, type) {
    if (pathname === void 0) { pathname = document.location.pathname; }
    var matches = [];
    routes.some(function (_a, _i) {
        var _path = _a[0], matchRoute = _a[1], navigate = _a[2], last = _a[3];
        // Ignore non-navigation routes on imperative URL changes
        if (!navigate) {
            switch (type) {
                case ROUTE_CHANGE_PUSH_STATE:
                case ROUTE_CHANGE_REPLACE_STATE:
                    return false;
                default:
                    break;
            }
        }
        // Evaluate the pathname and determine if we have a match
        var match = matchRoute(pathname);
        if (match) {
            matches.push(match);
            // Stop if this is a last match
            if (last) {
                return true;
            }
        }
        return false;
    });
    return matches;
}

var routeMaps = new Set();
var globalRoutes = [];
function resolveGlobalRoutes() {
    globalRoutes.length = 0;
    routeMaps.forEach(function (_a) {
        var routes = _a[0];
        globalRoutes.push.apply(globalRoutes, routes);
    });
    globalRoutes.sort(compareRoutes);
}
var isSubscribed = false;
function evaluate(pathname, state, type, routes) {
    if (pathname === void 0) { pathname = document.location.pathname; }
    if (state === void 0) { state = window.history.state; }
    if (type === void 0) { type = ROUTE_CHANGE_UNKNOWN; }
    if (routes === void 0) { routes = globalRoutes; }
    var matches = getMatchingRoutes(pathname, routes, type);
    if (!matches) {
        return undefined;
    }
    var results = matches.map(function (match) { return match.callback(match.params, type, pathname, state, match.path); });
    // We're only returning the first result. Could this be better? Maybe!
    return results[0];
}
function navigate(path, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.force, force = _c === void 0 ? false : _c, _d = _b.replaceState, replaceState = _d === void 0 ? false : _d, _e = _b.state, state = _e === void 0 ? {} : _e, _f = _b.title, title = _f === void 0 ? document.title : _f;
    var type;
    if (replaceState) {
        type = force ? ROUTE_CHANGE_FORCE_REPLACE_STATE : ROUTE_CHANGE_REPLACE_STATE;
        window.history.replaceState(state, title, path);
    }
    else {
        type = force ? ROUTE_CHANGE_FORCE_PUSH_STATE : ROUTE_CHANGE_PUSH_STATE;
        window.history.pushState(state, title, path);
    }
    return evaluate(document.location.pathname, state, type, globalRoutes);
}
function handlePopState(event) {
    evaluate(document.location.pathname, event.state, ROUTE_CHANGE_POP_STATE, globalRoutes);
}
function registerRoutes(routes, callback) {
    var processedRoutes = processRoutes(routes, callback);
    var routeMapEntry = [processedRoutes, callback];
    routeMaps.add(routeMapEntry);
    globalRoutes.push.apply(globalRoutes, processedRoutes);
    globalRoutes.sort(compareRoutes);
    if (!isSubscribed) {
        window.addEventListener('popstate', handlePopState);
        isSubscribed = true;
    }
    function evaluateRoutes(pathname, state, type) {
        if (pathname === void 0) { pathname = document.location.pathname; }
        if (state === void 0) { state = window.history.state; }
        return evaluate(pathname, state, type, processedRoutes);
    }
    function unregisterRoutes() {
        routeMaps.delete(routeMapEntry);
        resolveGlobalRoutes();
        if (!routeMaps.size) {
            window.removeEventListener('popstate', handlePopState);
            isSubscribed = false;
        }
    }
    return {
        unregisterRoutes: unregisterRoutes,
        evaluate: evaluateRoutes,
    };
}

exports.ROUTE_CHANGE_FORCE_PUSH_STATE = ROUTE_CHANGE_FORCE_PUSH_STATE;
exports.ROUTE_CHANGE_FORCE_REPLACE_STATE = ROUTE_CHANGE_FORCE_REPLACE_STATE;
exports.ROUTE_CHANGE_INITIALIZE = ROUTE_CHANGE_INITIALIZE;
exports.ROUTE_CHANGE_POP_STATE = ROUTE_CHANGE_POP_STATE;
exports.ROUTE_CHANGE_PUSH_STATE = ROUTE_CHANGE_PUSH_STATE;
exports.ROUTE_CHANGE_REPLACE_STATE = ROUTE_CHANGE_REPLACE_STATE;
exports.ROUTE_CHANGE_UNKNOWN = ROUTE_CHANGE_UNKNOWN;
exports.compareRoutes = compareRoutes;
exports.evaluate = evaluate;
exports.getMatchingRoutes = getMatchingRoutes;
exports.navigate = navigate;
exports.processRoutes = processRoutes;
exports.registerRoutes = registerRoutes;
